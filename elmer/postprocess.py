#!/usr/bin/env python

import sys
sys.path.insert(0, "../scripts")

from scipy.spatial import cKDTree
from matplotlib.tri import *        # Note: need matplotlib 1.4.2

from elmer import *
from meshes import *
from write_qgis import *


# ---------------------------------------------------------------------------- #
def reconcile_elmer_with_mesh(xt, yt, xe, ye):                                 #
# ---------------------------------------------------------------------------- #
    """
    Find a permutation which will map the ordering of the unknowns in the Elmer
    mesh to the original mesh as generated by Triangle
    """
    nn = len(xt)
    p = np.zeros(nn, dtype = int)

    Xe = np.zeros((nn, 2))
    Xe[:,0] = xe
    Xe[:,1] = ye

    Xt = np.zeros((nn, 2))
    Xt[:,0] = xt
    Xt[:,1] = yt

    tree = cKDTree(Xe)

    _, p = tree.query(Xt)

    return p


# ---------------------------------------------------------------------------- #
def get_field(field, glacier, partitions, mesh, surface = "bottom"):           #
# ---------------------------------------------------------------------------- #
    '''
    Get the values of a field from Elmer's output on either the top or bottom
    surface.

    Paramters:
    =========
    field: name of the field to get, e.g. beta, pressure, velod 1, etc.
    glacier: name of the glacier, either kangerd, helheim or jakobshavn
    surface: either "top" or "bottom", the layer we want to get the field from
    partitions: the number of partitions of the Elmer mesh
    mesh: a matplotlib.tri object encapsulating the original Triangle mesh
            used to generated the Elmer mesh

    Outputs:
    =======
    q: the desired field, reconciled to the node ordering of `mesh`
    '''
    directory = glacier + "3d"
    filename = "Test_Robin_Beta.result"

    data = get_variable(field, directory, filename, partitions)
    x, y, q = get_layer(data, surface)

    permutation = reconcile_elmer_with_mesh(mesh.x, mesh.y, x, y)
    return q[permutation]


# ---------------------------------------------------------------------------- #
if __name__ == "__main__":                                                     #
# ---------------------------------------------------------------------------- #
    glacier = sys.argv[1]

    # First, load in the Triangle mesh for the glacier
    mesh_file_stem = "../meshes/" + glacier + "/" + glacier + ".2"
    xm, ym, ele, bnd = read_triangle_mesh(mesh_file_stem)
    tri = Triangulation(xm, ym, ele)

    # Now get the basal friction parameter and the horizontal velocities at
    # the bed from Elmer's output
    beta = get_field("beta", glacier, 4, tri, surface = "bottom")
    u = get_field("velod 1", glacier, 4, tri, surface = "bottom")
    v = get_field("velod 2", glacier, 4, tri, surface = "bottom")

    # Interpolate the results to a regularly spaced grid
    xmin = 100.0 * math.floor(np.min(xm)/100.0)
    xmax = 100.0 * math.ceil(np.max(xm)/100.0)
    ymin = 100.0 * math.floor(np.min(ym)/100.0)
    ymax = 100.0 * math.ceil(np.max(ym)/100.0)

    x = np.linspace(xmin, xmax, (xmax - xmin)/100.0 + 1)
    y = np.linspace(ymin, ymax, (ymax - ymin)/100.0 + 1)

    nx = len(x)
    ny = len(y)

    tau = -9999.0 * np.ones((ny, nx))

    finder = tri.get_trifinder()
    interp_beta = LinearTriInterpolator(tri, beta, trifinder = finder)
    interp_uvel = LinearTriInterpolator(tri, u,    trifinder = finder)
    interp_vvel = LinearTriInterpolator(tri, v,    trifinder = finder)

    for i in range(ny):
        for j in range(nx):
            k = int(finder(x[j], y[i]))
            if k != -1:
                Beta = interp_beta(x[j], y[i])
                U    = interp_uvel(x[j], y[i])
                V    = interp_vvel(x[j], y[i])
                tau[i, j] = 1000 * Beta**2 * math.sqrt(U**2 + V**2)

    # Write the interpolated basal shear stress to the QGIS format
    write_to_qgis(glacier + "_taub.txt", tau, x[0], y[0], 100.0, -9999)

