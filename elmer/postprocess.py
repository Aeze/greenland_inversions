#!/usr/bin/env python

import sys
sys.path.insert(0, "../scripts")
import getopt
from os.path import expanduser

from scipy.spatial import cKDTree
from matplotlib.tri import *        # Note: need matplotlib 1.4.2

from elmer import *
from meshes import *
from write_qgis import *


# ---------------------------------------------------------------------------- #
def reconcile_elmer_with_mesh(xt, yt, xe, ye):                                 #
# ---------------------------------------------------------------------------- #
    """
    Find a permutation which will map the ordering of the unknowns in the Elmer
    mesh to the original mesh as generated by Triangle
    """
    nn = len(xt)
    p = np.zeros(nn, dtype = int)

    Xe = np.zeros((nn, 2))
    Xe[:,0] = xe
    Xe[:,1] = ye

    Xt = np.zeros((nn, 2))
    Xt[:,0] = xt
    Xt[:,1] = yt

    tree = cKDTree(Xe)

    _, p = tree.query(Xt)

    return p


# ---------------------------------------------------------------------------- #
def get_field(field, directory, partitions, mesh, surface = "bottom"):         #
# ---------------------------------------------------------------------------- #
    '''
    Get the values of a field from Elmer's output on either the top or bottom
    surface.

    Paramters:
    =========
    field: name of the field to get, e.g. beta, pressure, velod 1, etc.
    glacier: name of the glacier, either kangerd, helheim or jakobshavn
    surface: either "top" or "bottom", the layer we want to get the field from
    partitions: the number of partitions of the Elmer mesh
    mesh: a matplotlib.tri object encapsulating the original Triangle mesh
            used to generated the Elmer mesh

    Outputs:
    =======
    q: the desired field, reconciled to the node ordering of `mesh`
    '''
    filename = "Test_Robin_Beta.result"

    data = get_variable(field,
                        expanduser(directory),
                        expanduser(filename),
                        partitions)
    x, y, q = get_layer(data, surface)

    permutation = reconcile_elmer_with_mesh(mesh.x, mesh.y, x, y)
    return q[permutation]


# ---------------------------------------------------------------------------- #
def main(argv):                                                                #
# ---------------------------------------------------------------------------- #
    mesh_file = ''
    elmer_dir = ''
    out_file  = ''

    helps = ("Script to postprocess Elmer output into QGIS format.\n\n"
             "Usage: python postprocess.py -m <mesh file stem>"
                    " -e <Elmer output dir> -o <output file name>\n"
             "mesh file stem: path to Triangle mesh and file stem, e.g.\n"
             "    /home/daniel/greenland_inversions/meshes/helheim.2\n"
             "Elmer output dir: path to the Elmer output folder, e.g.\n"
             "    /home/daniel/greenland_inversions/elmer/helheim3d\n"
             "Output file name: path & filename to output the result\n")

    # Parse command-line arguments
    try:
        opts, args = getopt.getopt(argv, "hm:e:o:")
    except getopt.GetoptError:
        print(helps)
        sys.exit(1)

    for opt, arg in opts:
        if opt in ('-h', "--h", "--help"):
            print(helps)
            sys.exit(0)
        elif opt in ("-m", "--m", "-M", "--M", "-mesh", "--mesh"):
            mesh_file = arg
        elif opt in ("-e", "--e", "-E", "--E", "-elmer", "--elmer"):
            elmer_dir = arg
        elif opt in ("-o", "--o", "-output", "--output"):
            out_file = arg
        else:
            print(helps)
            sys.exit(1)

    # Load in the Triangle mesh for the glacier
    xm, ym, ele, bnd = read_triangle_mesh(expanduser(mesh_file))
    tri = Triangulation(xm, ym, ele)

    # Get the basal friction parameter and the sliding velocities from Elmer
    beta = get_field("beta", elmer_dir, 4, tri, surface = "bottom")
    u = get_field("velod 1", elmer_dir, 4, tri, surface = "bottom")
    v = get_field("velod 2", elmer_dir, 4, tri, surface = "bottom")

    # Interpolate the results to a regularly spaced grid
    xmin = 100.0 * math.floor(np.min(xm)/100.0)
    xmax = 100.0 * math.ceil(np.max(xm)/100.0)
    ymin = 100.0 * math.floor(np.min(ym)/100.0)
    ymax = 100.0 * math.ceil(np.max(ym)/100.0)

    x = np.linspace(xmin, xmax, (xmax - xmin)/100.0 + 1)
    y = np.linspace(ymin, ymax, (ymax - ymin)/100.0 + 1)

    nx = len(x)
    ny = len(y)

    tau = -9999.0 * np.ones((ny, nx))

    # Note: this part needs matplotlib 1.4.2 to work correctly
    finder = tri.get_trifinder()
    interp_beta = LinearTriInterpolator(tri, beta, trifinder = finder)
    interp_uvel = LinearTriInterpolator(tri, u,    trifinder = finder)
    interp_vvel = LinearTriInterpolator(tri, v,    trifinder = finder)

    for i in range(ny):
        for j in range(nx):
            k = int(finder(x[j], y[i]))
            if k != -1:
                Beta = interp_beta(x[j], y[i])
                U    = interp_uvel(x[j], y[i])
                V    = interp_vvel(x[j], y[i])
                tau[i, j] = 1000 * Beta**2 * math.sqrt(U**2 + V**2)

    # Write the interpolated basal shear stress to the QGIS format
    write_to_qgis(out_file, tau, x[0], y[0], 100.0, -9999)


if __name__ == "__main__":
    main(sys.argv[1:])

