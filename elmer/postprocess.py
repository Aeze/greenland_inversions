#!/usr/bin/env python

import sys
sys.path.insert(0, "../scripts")
import argparse
from os.path import expanduser

from scipy.spatial import cKDTree
from matplotlib.tri import *        # Note: need matplotlib 1.4.2

from elmer import *
from meshes import *
from write_qgis import *


# ---------------------------------------------------------------------------- #
def reconcile_elmer_with_mesh(xt, yt, xe, ye):                                 #
# ---------------------------------------------------------------------------- #
    """
    Find a permutation which will map the ordering of the unknowns in the Elmer
    mesh to the original mesh as generated by Triangle
    """
    nn = len(xt)
    p = np.zeros(nn, dtype = int)

    Xe = np.zeros((nn, 2))
    Xe[:,0] = xe
    Xe[:,1] = ye

    Xt = np.zeros((nn, 2))
    Xt[:,0] = xt
    Xt[:,1] = yt

    tree = cKDTree(Xe)

    _, p = tree.query(Xt)

    return p


# ---------------------------------------------------------------------------- #
def get_field(field, directory, partitions, mesh, surface = "bottom"):         #
# ---------------------------------------------------------------------------- #
    '''
    Get the values of a field from Elmer's output on either the top or bottom
    surface.

    Paramters:
    =========
    field: name of the field to get, e.g. beta, pressure, velod 1, etc.
    glacier: name of the glacier, either kangerd, helheim or jakobshavn
    surface: either "top" or "bottom", the layer we want to get the field from
    partitions: the number of partitions of the Elmer mesh
    mesh: a matplotlib.tri object encapsulating the original Triangle mesh
            used to generated the Elmer mesh

    Outputs:
    =======
    q: the desired field, reconciled to the node ordering of `mesh`
    '''
    filename = "Test_Robin_Beta.result"

    data = get_variable(field,
                        expanduser(directory),
                        expanduser(filename),
                        partitions)
    x, y, q = get_layer(data, surface)

    permutation = reconcile_elmer_with_mesh(mesh.x, mesh.y, x, y)
    return q[permutation]


# ---------------------------------------------------------------------------- #
def main(argv):                                                                #
# ---------------------------------------------------------------------------- #
    mesh_file = ''
    elmer_dir = ''
    out_file  = ''

    # Parse command-line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("-e", "--elmer", required = True,
                        help = "Directory of Elmer result files")
    parser.add_argument("-m", "--mesh", required = True,
                        help = "Path to triangle mesh and file stem")
    parser.add_argument("-o", "--output", required = True,
                        help = "Output directory and file stem")

    args, _ = parser.parse_known_args(argv)

    mesh_file = args.mesh
    elmer_dir = args.elmer
    out_file  = args.output

    # Load in the Triangle mesh for the glacier
    xm, ym, ele, bnd = read_triangle_mesh(expanduser(mesh_file))
    tri = Triangulation(xm, ym, ele)

    # Get the basal friction parameter from Elmer
    beta = get_field("beta", elmer_dir, 4, tri, surface = "bottom")

    # Get the computed basal velocities
    uxb = get_field("velod 1", elmer_dir, 4, tri, surface = "bottom")
    uyb = get_field("velod 2", elmer_dir, 4, tri, surface = "bottom")

    # Get the computed surface velocities
    uxs = get_field("velod 1", elmer_dir, 4, tri, surface = "top")
    uys = get_field("velod 2", elmer_dir, 4, tri, surface = "top")

    # Interpolate the results to a regularly spaced grid
    xmin = 100.0 * math.floor(np.min(xm)/100.0)
    xmax = 100.0 * math.ceil(np.max(xm)/100.0)
    ymin = 100.0 * math.floor(np.min(ym)/100.0)
    ymax = 100.0 * math.ceil(np.max(ym)/100.0)

    x = np.linspace(xmin, xmax, (xmax - xmin)/100.0 + 1)
    y = np.linspace(ymin, ymax, (ymax - ymin)/100.0 + 1)

    nx = len(x)
    ny = len(y)

    tau = -9999.0 * np.ones((ny, nx))
    us  = -9999.0 * np.ones((ny, nx))
    ub  = -9999.0 * np.ones((ny, nx))

    # Note: this part needs matplotlib 1.4.2 to work correctly
    finder = tri.get_trifinder()
    interp_beta = LinearTriInterpolator(tri, beta, trifinder = finder)
    interp_uxb = LinearTriInterpolator(tri, uxb,   trifinder = finder)
    interp_uyb = LinearTriInterpolator(tri, uyb,   trifinder = finder)
    interp_uxs = LinearTriInterpolator(tri, uxs,   trifinder = finder)
    interp_uys = LinearTriInterpolator(tri, uys,   trifinder = finder)

    for i in range(ny):
        for j in range(nx):
            k = int(finder(x[j], y[i]))
            if k != -1:
                Beta = interp_beta(x[j], y[i])
                Uxb  = interp_uxb(x[j], y[i])
                Uyb  = interp_uyb(x[j], y[i])
                Uxs  = interp_uxs(x[j], y[i])
                Uys  = interp_uys(x[j], y[i])
                ub[i, j] = math.sqrt(Uxb**2 + Uyb**2)
                us[i, j] = math.sqrt(Uxs**2 + Uys**2)
                tau[i, j] = 1000 * Beta**2 * ub[i, j]

    # Write the interpolated basal shear stress to the QGIS format
    write_to_qgis(out_file + "_taub.txt", tau, x[0], y[0], 100.0, -9999)
    write_to_qgis(out_file + "_us.txt",   us,  x[0], y[0], 100.0, -9999)
    write_to_qgis(out_file + "_ub.txt",   ub,  x[0], y[0], 100.0, -9999)


if __name__ == "__main__":
    main(sys.argv[1:])

